#type: include

The finite element solver will recognize and use [attributes|/model/attributes] on the simulated geometry. In the DOP network, this simulation geometry is attached to the simulated object as a sim-data with name `Geometry`. When an object is created, then the geometry and all the corresponding attributes are read from the __Initial Geometry__. This includes the standard position and velocity point attributes `P` and `v`.

== User Control Attributes ==

You can locally change the material properties of the object using primitive attributes.
For example, you can make some polygons resists stretching and bending more than other polygons.
These attributes work as multipliers for the parameters in the __Material__ tab:

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `shellstretchstiffness` `shellshearstiffness` `shellweakbendstiffness` `shellstrongbendstiffness`
        td>> Primitive
        td>> Float
        td>> Multipliers for the object stiffness parameters.
    tr>>
        td>> `shellstretchdamping` `shellsheardamping` `shellweakbenddamping` `shellstrongbenddamping`
        td>> Primitive
        td>> Float
        td>> Multipliers for the object damping parameters.
    tr>>
        td>> `shapestiffness` `volumestiffness`
        td>> Primitive
        td>> Float
        td>> Multipliers for the object stiffness parameters.
    tr>>
        td>> `soliddampingratio`
        td>> Primitive
        td>> Float
        td>> Multipliers for the object damping ratio parameter.
    tr>>
        td>> `surfacemassdensity`
        td>> Primitive
        td>> Float
        td>> Multiplier for the object's __Surface Mass Density__.
    tr>>
        td>> `volumeemassdensity`
        td>> Primitive
        td>> Float
        td>> Multiplier for the object's __Volume Mass Density__.
    tr>>
        td>> `seamangle`
        td>> Primitive
        td>> Float
        td>> Multipliers for the object's __Seam Angle__.

When you create a simulation with fracturing, it is recommended to specify chunks of tetrahedrons that you want to stay together. Otherwise, the fracturing process may create a very large amount of separate pieces, many of which may consist of single tetrahedrons. For this purpose, you can assign a nonnegative integer to each chunk using the `fracturepart` attribute. In areas where you don't want to specify parts, you can set `fracturepart` to -1, which means that each primitive in that region will become its own part. Real-life materials tend not to be equally strong everywhere. For realistic results, it is recommended to vary the __Fracture Threshold__ locally using the vertex attribute `fracturethreshold`.

table>>
    tr>>
        td>> `fracturepart`
        td>> Primitive
        td>> Integer
        td>> Partitions the object into unbreakable parts. Must be either -1 (no part) or a nonnegative number that indicates a part.
    tr>>
        td>> `enablefracturing`
        td>> Point/Vertex
        td>> Integer
        td>> Locally enable/disable fracturing for points or vertices.
    tr>>
        td>> `fracturethreshold`
        td>> Point/Vertex
        td>> Float
        td>> Multiplier for the object's __Fracture Threshold__.

The collision behavior of the object can be modified locally using the following attributes that work as multipliers for the per-object parameters in the __Collisions__ tab:

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `thickness`
        td>> Primitive
        td>> Float
        td>> Multiplier for the object's __Thickness__.
    tr>>
        td>> `friction`
        td>> Primitive
        td>> Float
        td>> Multiplier for the object's __Friction__.

The behavior of the drag force can be modified locally using the following attributes:

table>>
        tr>>
                td>> `normaldrag`
                td>> Point
                td>> Float
                td>> Multiplier for the object's __Normal Drag__.
        tr>>
                td>> `tangentdrag`
                td>> Point
                td>> Float
                td>> Multiplier for the object's __Tangent Drag__.
               
The attribute `restP` can be used to specify the rest position for all the object points. The attribute `materialP` is similar to the rest position, but it must not be changed during a simulation. Among other things, `materialP` defines the mass and the strength of the internal forces that act within the simulation geometry. The attribute 'materialP' can be thought of as an initial rest position.
table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `materialP`
        td>> Point
        td>> Vector
        td>> Material position of each point.
    tr>>
        td>> `restP`
        td>> Point
        td>> Vector
        td>> Rest position of each point.
	
The attribute `baseP` can be used to specify a generic base position for all the object points. This attribute's values must not be changed during a simulation. When the user does not specify `baseP`, the solver creates this point attribute based on the point positions on the creation frame. This attribute is used as a fallback; whenever the user does not specify `materialP`, the attribute `baseP` is read instead. In the same way, `baseP` is used as a fallback for when no `restP` or `targetP` attributes are provided. Finally, `baseP` is used to bind the simulated and the embedded geometry, in the embedded workflow (e.g., a T-pose). This embedded binding looks at the `baseP` position attribute on both the simulated geometry and the embedded geometry. If no `baseP` attribute is provided by the user on the embedded geometry, the solver creates the `baseP` attribute on the embedded geometry based on the position `P` at the creation frame.  
    tr>>
        td>> `baseP`
        td>> Point
        td>> Vector
        td>> base position of each point

The attributes `targetP` and `targetv` can be used to specify a target position and velocity for each object point. When you use the __Import Target Geometry__ option on the simulated object, the `targetP` and `targetv` will be set automatically every frame. Alternatively, you can create and modify these attributes yourself, using a [Multi Solver|Node:dop/multisolver] and a [SOP Solver|Node:dop/sopsolver]. The target positions and velocities allow the user to mix animation and simulation in a very stable way (assuming the __Target Stiffness__ and __Target Damping__ parameters have been set on the object). You can set the __Target Stiffness__ and __Target Damping__ parameters on the object to express how strongly the object should match the target position and velocity, respectively. This is a way to create soft constraints. You can use the `pintoanimation` to create hard constraints that make the simulated points follow `targetP` and `targetv` exactly.
        
table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `targetP`
        td>> Point or Vertex
        td>> Vector
        td>> Target position of each point.
    tr>>
        td>> `targetv`
        td>> Point or Vertex
        td>> Vector
        td>> Target velocity of each point.
    tr>>
        td>> `targetstiffness`
        td>> Point
        td>> Float
        td>> Multiplier for the object's __Target Stiffness__.
    tr>>
        td>> `targetdamping`
        td>> Point
        td>> Float
        td>> Multiplier for the object's __Target Geometry__.
    tr>>
        td>> `pintoanimation`
        td>> Point
        td>> Float
        td>> Enable hard constraint to `targetP` and `targetv`.
 
The attribute `initialpid` stores the initial point index for each point. This is the point index at the creation time of the object. The point indices may change during a finite element simulation as a result of fracturing. The initial point indices allow DOP constraints to work on point even though the current point indices may change.
 
table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `initialpid`
        td>> Point
        td>> Integer
        td>> Initial point index for each point

The `force` and `fexternal` attributes can be used to influence the simulation by introducing an external force on each point. Note that the effect of the `force` (or `fexternal`) attribute is generally much less stable than the soft constraints that are based on `target` and `targetv`. So when you can, you should use the `target` and `targetv` attributes in combination with the __Target Stiffness__ and __Target Damping__ whenever you want to influence a finite element simulation.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `force` or `fexternal`
        td>> Point
        td>> Vector
        td>> External force applied to each point.
    tr>> 
        td>> `pintoanimation`
        td>> Point
        td>> Float
        td>> Animates each point that has value > 0.5.

== Reserved Solver Attributes ==

Below is a list of attributes that are maintained internally by the solver. Each of these attributes is written to at the end of each solve and read from at the start of the next solve. You should not modify any of these attributes yourself. When you do, the solver is likely to become unstable and you will get bad results. However, you can inspect the values in these attributes in your network for visualization or for the creation of secondary effects.

At each frame, the finite element solver computes a new physical state for each simulated object. The physical state of the object is represented by the point attributes `P` and `v`, representing the position and velocity, respectively. The solver's integration scheme maintains additional attributes `a` for acceleration and `j` for jerk.

The point attributes `P`, `v`, `a`, and `j` store the current integration state of the object. These attributes should not be modified during the simulation because the finite element solver will become unstable and produce low-quality results.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `P`
        td>> Point
        td>> Vector
        td>> Do not modify! Current position of each object point.
    tr>>
        td>> `v`
        td>> Point
        td>> Vector
        td>> Do not modify! Current velocity of each object point.
   tr>>
        td>> `accel`
        td>> Point
        td>> Vector
        td>> Do not modify! Current acceleration of each object point.
   tr>>
        td>> `jerk`
        td>> Point
        td>> Vector
        td>> Do not modify! Current jerk of each object point.

The solver itself maintains the attribute `restPprevious`, which should not be modified outside the solver.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
     tr>>
        td>> `restPprevious`
        td>> Point or Vertex
        td>> Vector
        td>> Do not modify! Previous rest positions maintained by the solver.

The attributes `targetPprevious` and `targetvnext` are maintained internally by the solver and should not be modified.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `targetPprevious`
        td>> Point
        td>> Vector
        td>> Do not modify! Previous rest positions maintained by the solver.
    tr>>
        td>> `targetvprevious`
        td>> Point
        td>> Vector
        td>> Do not modify! Previous rest velocities maintained by the solver.

If the option __Enable Fracturing__ is enabled on the finite element solver, then the `fracturecount` point attribute is created.
The point attribute `fracturecount` maintains for each point, the number of times that the point has been involved in a fracture. So any point with a nonzero value of `fracturecount` has been involved fracturing.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `fracturecount`
        td>> Point
        td>> Integer
        td>> The number of times a point was fractured during the simulation

If the __Create Quality Attributes__ option is enabled on the finite element solver, a primitive attribute `quality` is created for each primitive. This is a value between 0 and 1 that tells you how suitable the primitive is for simulation. The closer to 1 the `quality` is, the better suited the primitive is for simulation. If a mesh has one or more primitives with `quality` close to zero, the simulation can be slowed down or destabilized.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `quality`
        td>> Primitive
        td>> Float
        td>> Quality of primitive shape for simulation purposes

If the __Create Energy Attributes__ option is enabled on the finite element solver, then the following energy-density vertex attributes are generated on each object:

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `potentialdensity`
        td>> Vertex
        td>> Float
        td>> Density of the amount of potential energy
    tr>>
        td>> `dissipationdensity`
        td>> Vertex
        td>> Float
        td>> Density of the rate of energy dissipation
    tr>>
        td>> `kineticdensity`
        td>> Vertex
        td>> Float
        td>> Density of the kinetic energy

== Embedded Geometry Attributes ==

These attributes are created on the Embedded Geometry of the Solid Object.
The `parent` attribute is maintained by the embedding code itself, and
should not be modified.
The `baseP` point attribute can be provided on the Embedded Geometry by the user to control the binding between the simulated geometry and the embedded geometrylignment.
If no `baseP` is provided, it will be copied from the point positions stored in `P` at the creation frame.
The alignment happens relative to the `baseP` point attribute on the simulated geometry. If the simulated geometry has a `materialP` vertex or point attribute, then this attribute takes precedence, allowing control per vertex, rather than per point, if necessary.
When you want to ensure that embedded geometry ends up on the desired side of a fracture between simulated geometry, you can use the combination of vertex attributes `baseP` on the embedded geometry and `restP` on the simulated geometry.
This allows you to line up the embedded geometry with the separate parts in the simulated geometry, for example using the [Exploded View SOP|Node:sop/explodedview].
The `fracturepart` attribute allows you to make sure that the embedded geometry follows the right parts when it gets fractured. When both the simulated and the embedded geometry have the `fracturepart` attribute, the finite element solver will parent embedded geometry to simulated geometry that has the same fracture part.

table>>
    tr>>
        th>> Name
        th>> Class
        th>> Type
        th>> Description
    tr>>
        td>> `parent`
        td>> Primitive
        td>> Float
        td>> The index of a parent primitive in the simulated geometry
    tr>>
        td>> `baseP`
        td>> Point
        td>> Float
        td>> Base positions used for alignment with simulated mesh
    tr>>
        td>> `fracturepart`
        td>> Point or Vertex
        td>> Float
        td>> Optional user-specified fracture part ID
    tr>>
        td>> `P`
        td>> Point
        td>> Float
        td>> Positions that correspond to the deformed state
    tr>>
        td>> `v`
        td>> Point
        td>> Float
        td>> Velocities that correspond to the deformed state
    tr>>
        td>> `N`
        td>> Point or Vertex
        td>> Float
        td>> Normals that correspond to the deformed state









    
 
