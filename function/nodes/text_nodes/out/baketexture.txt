= Bake Texture =

#type: node
#context: out
#internal: baketexture
#icon: ROP/mantra

"""Generates a texture map from one or more objects' rendered appearance."""

== Overview ==

It can be useful to generate a texture from the rendered appearance of a model.

* As a performance "cheat", you can bake the fully rendered appearance of a model into a texture, and then use the texture instead of running the actual shaders. When you can get away with it (where it's not noticeable that the object's appearance doesn't change), this can give a large speedup, especially for large numbers of identical objects with complex shaders.

    This is especially useful when you [bake a texture from a high-resolution model and apply it to a low-resolution model|#xfer], possibly in combination with other resolution "tricks" such as subdivision surfaces.

* You can capture the rendered appearance of a model as the starting point for a hand-painted texture map.

This node renders one or more objects as flat texture maps.

== UDIM and Ptex ==

This node can generate UDIM unwrapped texture images, or [Ptex|/shade/ptex] texture maps, using the __UV unwrapping method__ parameter.

* For UDIM textures, the node will use the `uv` attribute on the model to lay out the baked output.

    The node will replace the string `%(UDIM)d` in the output filename with the UDIM index.

* [Ptex|/shade/ptex] generates a separate texture for each face and saves all the textures and the model topology together in a single archive. Since Ptex texture tiles must map to quadrilaterals, Mantra assumes the geometry will render as a subdivision surface. This node creates Ptex tiles for each polygon using the subdivision rules (3 faces for a triangle, 1 for a quad, 5 for a pentagon, 6 for a hexagon, and so on).

== Baking high-res object onto low-res object == (xfer)

When you specify the objects to render in the __UV render objects__, you can optionally render the appearance of one object into the UV space of another object. This is useful for baking the look of high-res geometry and complex shaders, and then applying them to a much lower-resolution object.

== Object pattern matching ==

You can use the __UV render objects__ parameter to specify multiple objects to render. You can also use wildcards in the __UV render objects__ sub-parameters to match multiple objects in one go.

When you have one pattern in the __UV object__ path, and a corresponding `*` wildcard in the __Output picture__ filename, the node will replace the `*` in the filename with the match from the object path.

For example, if the __UV object__ path is `/obj/*`, and the __Output picture__ filename is `$HIP/textures/*.rat`, then the node will render `/obj/apple` as `$HIP/textures/apple.rat`, `/obj/bear` as `$HIP/textures/bear.rat`, and so on.

Note that the pattern in the __UV object__ path can be something other than a `*`. For example, if you have the objects `/obj/ball1`, `/obj/ball2`, and `/obj/ball3`, you could use a path of `/obj/ball[1-3]` and an output filename like `$HIP/textures/*.rat`.

== Tips and notes ==

* As with a regular render, you can output multiple image planes as textures. For example shading position, direct lighting, indirect lighting, and so on.

* Mantra unwraps the model using a lens shader (see `$HH/CVex/uvlens.vfl`). Mantra only supports lens shaders in ray-tracing and PBR ray-tracing.

* The lens shader raises the "camera" very slightly above the surface, to account for precision errors in calculating the surface position. This means it's very important to have correct surface normals on the model. If the model's normals are reversed for some reason, you can un-reverse them on this node using the __Reverse normals__ parameter.

*  The [Vex:uvunwrap] function the lens shader uses correctly accounts for subdivided surfaces and displacement shaders when calculating the surface positions.

@parameters

This is a version of the regular [Mantra render node|Node:out/ifd] which is configured with parameters to allow for easy baking of texture maps for objects. See the [help for the render node|Node:out/ifd] for more general help.

UV Unwrapping Method:
    Choose `UDIM` to generate regular UV images, `Ptex` to generate Ptex images.

Resolution:
    The size of the output texture image. This is ignored for Ptex textures. This can be from `128` to `2048` pixels.

Minimum Map Resolution:
    For Ptex, the texture size to use for the smallest faces in each object, from `4` to `1024` pixels.

Maximum Map Resolution:
    For Ptex, the maximum possible texture size to use, from `4` to `1024` pixels. This is a clamp on the per-face value calculated by multiplying the __Minimum map resolution__ by the __Map resolution scale__.

Map Resolution Scale:
    For Ptex, this node calculates the size of each texture by scaling the __Minimum map resolution__ based on the relative size of each face. The smallest faces will get the __Minimum map resolution__. With a scale of `1.0`, faces 2x larger than the smallest will get 2x larger textures. If you set the scale to `0.0`, _all_ faces will get the minimum resolution.

UV Render Objects:
    For each object you want to render, click the [Smallicon:BUTTONS/add] Add button and enter the path of the object in __UV Object__, and the texture filename in __Output picture__. You can do [simple pattern expansion|#patterns] in the path and filename.
    
    To take the rendered appearance of a high resolution object and bake it into the texture space of the __UV object__, enter the path of the __High res object__.
    
    When __Texture unwrapping method__ is "UDIM", you can use `%(UDIM)d` in the filename, and the node will replace it with the UDIM index to render out multiple files.

UV Attribute:
    When __UV unwrapping method__ is "UDIM", use this attribute for UVs. The default is the standard `uv` attribute created by UV tools in Houdini. Ptex does not require UV coordinates on the model.

Orient Ptex Subfaces Clockwise:
    When __UV unwrapping method__ is "Ptex", turn this off if you're exporting the texture to a software package that orients faces counter-clockwise instead of clockwise like Houdini.

Ray Bias:
    The lens shader moves the camera this small distance above the surface, along the surface normal, to avoid intersection artifacts. You can increase this distance if you still see artifacts.

Reverse Normals:
    The lens shader moves the camera a small distance above the surface, along the surface normal, to avoid intersection artifacts. If the normals on your model are reversed for some reason, you can turn this on as a quick fix.

Exclude Light Paths:
    The renderer will _not_ use any light paths that match this pattern when rendering the texture. The default is <code>&#x2011;diffuse & &#x2011;volume</code>, meaning the node will _only_ render the `diffuse` and `volume` light paths (the double-negative can be confusing). Since `specular` and `refraction` light paths are view
    dependent, you usually don't want to bake them into texture maps.

Post Process UDIM Images:
    UDIM unwrapping tends to generate islands of texture surrounded by empty space. This can be a problem when filtering pixels at the boundaries of the islands since they will pick up black from the empty space. This parameter has several choices for mitigating the problem.

    Border Expansion:
        Does a flood fill on the image and expands the boundary of each UV island. 
    
    Fill Background:
        Does a simple fill of empty space using the average of all valid pixels in the texture image.
    
    While not perfect, this does help decrease MIP-map artifacts on UDIM textures.

Additional Pixels at Border:
    The number of pixels to expand UV islands, when __Post Process UDIM Images__ is "Border expansion".

@related

- [Mantra|Node:out/ifd]
